<!DOCTYPE html>
 <html>
 <html lang="en">
 <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Honeypot Dashboard</title>
     <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&family=JetBrains+Mono&display=swap" rel="stylesheet">
     <style>
         :root {
             --primary: #4361ee;
             --danger: #f72585;
             --success: #4cc9f0;
             --dark: #212529;
             --light: #f8f9fa;
             --gray: #6c757d;
         }
         
         body {
             font-family: Arial, sans-serif;
             max-width: 800px;
             font-family: 'Roboto', sans-serif;
             background-color: #f5f7fa;
             color: var(--dark);
             margin: 0;
             padding: 0;
         }
         
         .container {
             max-width: 1400px;
             margin: 0 auto;
             padding: 20px;
         }
         .panel {
             background: #f8f9fa;
         
         header {
             background: linear-gradient(135deg, var(--primary), #3a0ca3);
             color: white;
             padding: 1.5rem;
             border-radius: 8px;
             margin-bottom: 2rem;
             box-shadow: 0 4px 6px rgba(0,0,0,0.1);
         }
         
         h1 {
             margin: 0;
             font-weight: 500;
             display: flex;
             align-items: center;
             gap: 10px;
         }
         
         .status-badge {
             background-color: var(--success);
             padding: 3px 8px;
             border-radius: 12px;
             font-size: 0.8rem;
             display: inline-flex;
             align-items: center;
             gap: 5px;
         }
         
         .status-badge::before {
             content: "•";
             font-size: 1.5rem;
         }
         
         .grid {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
             gap: 20px;
             margin-bottom: 2rem;
         }
         
         .card {
             background: white;
             border-radius: 8px;
             box-shadow: 0 2px 4px rgba(0,0,0,0.05);
             overflow: hidden;
         }
         
         .card-header {
             background-color: var(--dark);
             color: white;
             padding: 12px 20px;
             display: flex;
             justify-content: space-between;
             align-items: center;
         }
         
         .card-body {
             padding: 20px;
             margin-bottom: 20px;
             max-height: 400px;
             overflow-y: auto;
         }
         button {
             background: #0066cc;
         
         .log-entry {
             font-family: 'JetBrains Mono', monospace;
             font-size: 0.85rem;
             padding: 8px 0;
             border-bottom: 1px solid #eee;
             display: flex;
             gap: 10px;
         }
         
         .log-time {
             color: var(--gray);
             min-width: 180px;
         }
         
         .log-message {
             flex-grow: 1;
             word-break: break-all;
         }
         
         .http-get { color: var(--success); }
         .http-post { color: #f8961e; }
         .http-put { color: #90be6d; }
         .http-delete { color: var(--danger); }
         
         .btn {
             background-color: var(--primary);
             color: white;
             border: none;
             padding: 8px 15px;
             padding: 8px 16px;
             border-radius: 4px;
             cursor: pointer;
             margin: 5px 0;
             font-weight: 500;
             transition: all 0.2s;
         }
         .log-entry {
             padding: 8px 0;
             border-bottom: 1px solid #eee;
         
         .btn:hover {
             opacity: 0.9;
             transform: translateY(-1px);
         }
         
         .btn-sm {
             padding: 5px 10px;
             font-size: 0.8rem;
         }
         .error {
             color: #dc3545;
         
         .input-group {
             display: flex;
             gap: 10px;
             margin-top: 15px;
         }
         #connectionStatus {
             padding: 10px;
             margin-bottom: 15px;
         
         input[type="text"] {
             flex-grow: 1;
             padding: 8px 12px;
             border: 1px solid #ddd;
             border-radius: 4px;
             font-family: 'JetBrains Mono', monospace;
         }
         
         .alert {
             padding: 10px 15px;
             border-radius: 4px;
             margin: 10px 0;
         }
         
         .alert-success {
             background-color: #e6f7e6;
             color: #2e7d32;
         }
         
         .alert-error {
             background-color: #ffebee;
             color: #c62828;
         }
         
         .connection-status {
             display: flex;
             align-items: center;
             gap: 8px;
             margin-top: 10px;
         }
         .status-good {
             background: #e6f7e6;
             border-left: 4px solid #4CAF50;
         
         .connection-dot {
             width: 10px;
             height: 10px;
             border-radius: 50%;
             background-color: var(--success);
             animation: pulse 2s infinite;
         }
         
         @keyframes pulse {
             0% { opacity: 1; }
             50% { opacity: 0.5; }
             100% { opacity: 1; }
         }
         .status-bad {
             background: #ffebee;
             border-left: 4px solid #f44336;
         
         /* Dark mode toggle */
         .dark-mode-toggle {
             position: fixed;
             bottom: 20px;
             right: 20px;
             z-index: 100;
         }
     </style>
 </head>
 <body>
     <div id="connectionStatus" class="status-good">
         ✓ Connected to backend at <span id="connectionTime"></span>
     </div>
 
     <div class="panel">
         <h1>Wikipedia Honeypot Monitor</h1>
     <div class="container">
         <header>
             <h1>
                 <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                     <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
                 </svg>
                 Honeypot Security Dashboard
                 <span class="status-badge" id="connectionStatus">Connected</span>
             </h1>
             <div class="connection-status">
                 <div class="connection-dot"></div>
                 <span id="connectionTime"></span>
             </div>
         </header>
 
         <div class="panel">
             <h2>Attack Logs</h2>
             <button onclick="fetchLogs()">Refresh</button>
             <div id="attackLogs">Loading logs...</div>
         </div>
         
         <div class="panel">
             <h2>Blocked IPs</h2>
             <button onclick="fetchBlockedIPs()">Refresh</button>
             <div id="blockedIPs">Loading blocked IPs...</div>
         <div class="grid">
             <div class="card">
                 <div class="card-header">
                     <h2>Attack Logs</h2>
                     <button class="btn btn-sm" onclick="fetchLogs()">Refresh</button>
                 </div>
                 <div class="card-body" id="attackLogs">
                     <div class="log-entry">
                         <span class="log-time">[Loading...]</span>
                         <span class="log-message">Initializing attack logs</span>
                     </div>
                 </div>
             </div>
             
             <div class="card">
                 <div class="card-header">
                     <h2>Blocked IPs</h2>
                     <button class="btn btn-sm" onclick="fetchBlockedIPs()">Refresh</button>
                 </div>
                 <div class="card-body" id="blockedIPs">
                     <div class="log-entry">
                         <span class="log-time">[Loading...]</span>
                         <span class="log-message">Loading blocked IPs</span>
                     </div>
                 </div>
             </div>
         </div>
 
         <div class="panel">
             <h2>Manual IP Management</h2>
             <input type="text" id="ipAddress" placeholder="Enter IP address">
             <button onclick="unblockIP()">Unblock</button>
             <div id="unblockStatus"></div>
         <div class="grid">
             <div class="card">
                 <div class="card-header">
                     <h2>Access Logs (Live)</h2>
                     <button class="btn btn-sm" onclick="fetchAccessLogs()">Refresh</button>
                 </div>
                 <div class="card-body" id="accessLogs">
                     <div class="log-entry">
                         <span class="log-time">[Loading...]</span>
                         <span class="log-message">Initializing access logs</span>
                     </div>
                 </div>
             </div>
             
             <div class="card">
                 <div class="card-header">
                     <h2>IP Management</h2>
                 </div>
                 <div class="card-body">
                     <div class="input-group">
                         <input type="text" id="ipAddress" placeholder="Enter IP address">
                         <button class="btn" onclick="unblockIP()">Unblock</button>
                     </div>
                     <div id="unblockStatus"></div>
                     
                     <h3>Quick Actions</h3>
                     <button class="btn btn-sm" onclick="clearLogs()">Clear All Logs</button>
                     <button class="btn btn-sm" style="background-color: var(--danger);" onclick="simulateAttack()">Simulate Attack</button>
                 </div>
             </div>
         </div>
     </div>
 
     <button class="dark-mode-toggle btn" onclick="toggleDarkMode()">🌓 Dark Mode</button>
 
     <script>
         // Update connection time display
         // Connection monitoring
         function updateConnectionTime() {
             document.getElementById('connectionTime').textContent = 
                 new Date().toLocaleTimeString();
         }
         setInterval(updateConnectionTime, 1000);
         updateConnectionTime();
 
         async function checkBackendConnection() {
             try {
                 const response = await fetch('/api/test-connection');
                 if (!response.ok) throw new Error(`Server returned ${response.status}`);
                 return true;
             } catch (error) {
                 document.getElementById('connectionStatus').className = 'status-bad';
                 document.getElementById('connectionStatus').innerHTML = 
                     `✗ Connection failed: ${error.message}`;
                 return false;
             }
         // Format log entries
         function formatLogEntry(line) {
             if (!line) return '';
             
             // Color code by HTTP method
             const method = line.match(/"([A-Z]+)/)?.[1] || '';
             const methodClass = method ? `http-${method.toLowerCase()}` : '';
             
             // Extract timestamp if available
             const timestampMatch = line.match(/\[(.*?)\]/);
             const timestamp = timestampMatch ? timestampMatch[1] : new Date().toISOString();
             
             return `
                 <div class="log-entry">
                     <span class="log-time">[${timestamp}]</span>
                     <span class="log-message ${methodClass}">${line}</span>
                 </div>
             `;
         }
 
         // Enhanced logging functions
         async function fetchLogs() {
             if (!await checkBackendConnection()) return;
             
             try {
                 const response = await fetch('/api/logs');
                 if (!response.ok) throw new Error(`HTTP ${response.status}`);
                 const logs = await response.text();
 
                 document.getElementById('attackLogs').innerHTML = 
                     logs.split('\n').map(line => 
                         line ? `<div class="log-entry">${line}</div>` : '<div>No logs found</div>'
                     logs.split('\n').reverse().map(line => 
                         formatLogEntry(line) || '<div class="log-entry">No logs found</div>'
                     ).join('');
             } catch (error) {
                 document.getElementById('attackLogs').innerHTML = 
                     `<div class="error">Error loading logs: ${error.message}</div>`;
                 document.getElementById('attackLogs').innerHTML = `
                     <div class="alert alert-error">
                         Error loading logs: ${error.message}
                     </div>
                 `;
             }
         }
 
         async function fetchBlockedIPs() {
             if (!await checkBackendConnection()) return;
             
             try {
                 const response = await fetch('/api/blocked-ips');
                 if (!response.ok) throw new Error(`HTTP ${response.status}`);
                 const ips = await response.text();
 
                 document.getElementById('blockedIPs').innerHTML = 
                     ips.split('\n').filter(ip => ip.trim()).map(ip => 
                         `<div class="log-entry">${ip}</div>`
                     ).join('') || '<div>No blocked IPs found</div>';
                     ips.split('\n').filter(ip => ip.trim()).map(ip => `
                         <div class="log-entry">
                             <span class="log-time">${ip.split(' - ')[1] || ''}</span>
                             <span class="log-message">${ip.split(' - ')[0]}</span>
                         </div>
                     `).join('') || '<div class="log-entry">No blocked IPs</div>';
             } catch (error) {
                 document.getElementById('blockedIPs').innerHTML = 
                     `<div class="error">Error loading blocked IPs: ${error.message}</div>`;
                 document.getElementById('blockedIPs').innerHTML = `
                     <div class="alert alert-error">
                         Error loading blocked IPs: ${error.message}
                     </div>
                 `;
             }
         }
 
         async function unblockIP() {
             const ip = document.getElementById('ipAddress').value.trim();
             if (!ip) {
                 document.getElementById('unblockStatus').innerHTML = 
                     '<div class="error">Please enter an IP address</div>';
                 return;
             }
 
         async function fetchAccessLogs() {
             try {
                 const response = await fetch('/api/unblock', {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/x-www-form-urlencoded',
                     },
                     body: `ip=${encodeURIComponent(ip)}`
                 });
                 
                 const result = await response.text();
                 if (!response.ok) throw new Error(result);
                 const response = await fetch('/api/access-logs');
                 if (!response.ok) throw new Error(`HTTP ${response.status}`);
                 const logs = await response.text();
 
                 document.getElementById('unblockStatus').innerHTML = 
                     `<div style="color:green">Successfully unblocked ${ip}</div>`;
                 fetchBlockedIPs();
                 document.getElementById('accessLogs').innerHTML = 
                     logs.split('\n').reverse().filter(line => line.trim()).map(line => 
                         formatLogEntry(line)
                     ).join('') || '<div class="log-entry">No access logs</div>';
             } catch (error) {
                 document.getElementById('unblockStatus').innerHTML = 
                     `<div class="error">Unblock failed: ${error.message}</div>`;
                 console.error("Error fetching access logs:", error);
             }
         }
 
         // Auto-refresh
         setInterval(fetchAccessLogs, 5000);
         setInterval(fetchLogs, 10000);
         setInterval(fetchBlockedIPs, 10000);
 
         async function verifySetup() {
     try {
         // 1. First check basic connection
         const testConn = await fetch('/api/test-connection');
         if (!testConn.ok) throw new Error("Backend not responding");
         
         // 2. Check if files exist
         const verify = await fetch('/api/verify');
         const data = await verify.json();
         
         // 3. Create files if missing
         if (!data['/api/logs'] || !data['/api/blocked-ips']) {
             const create = await fetch('/api/create-test-files');
             if (!create.ok) throw new Error("Couldn't create log files");
         }
         
         // 4. Now fetch actual data
         // Initial load
         fetchLogs();
         fetchBlockedIPs();
         fetchAccessLogs();
 
         // [Keep all your existing functions like unblockIP(), verifySetup(), etc.]
 
     } catch (error) {
         document.getElementById('attackLogs').innerHTML = 
             `<div class="error">Setup error: ${error.message}</div>`;
         document.getElementById('blockedIPs').innerHTML = 
             `<div class="error">Setup error: ${error.message}</div>`;
     }
 }
         // New utility functions
         function toggleDarkMode() {
             document.body.classList.toggle('dark-mode');
             // Note: You'll need to add dark mode CSS styles
         }
 
 // Replace the initial load at bottom of script with:
 verifySetup();
         // Initial load
         checkBackendConnection();
         fetchLogs();
         fetchBlockedIPs();
         function clearLogs() {
             if (confirm("Clear all logs? This cannot be undone.")) {
                 fetch('/api/clear-logs', { method: 'POST' })
                     .then(response => {
                         if (response.ok) {
                             fetchLogs();
                             fetchAccessLogs();
                             showAlert('Logs cleared successfully', 'success');
                         }
                     });
             }
         }
 
         function simulateAttack() {
             fetch('/api/simulate-attack')
                 .then(response => {
                     if (response.ok) {
                         showAlert('Test attack simulated', 'success');
                         fetchLogs();
                         fetchBlockedIPs();
                     }
                 });
         }
 
         function showAlert(message, type) {
             const alert = document.createElement('div');
             alert.className = `alert alert-${type}`;
             alert.textContent = message;
             document.body.appendChild(alert);
             setTimeout(() => alert.remove(), 3000);
         }
     </script>
 </body>
 </html>
